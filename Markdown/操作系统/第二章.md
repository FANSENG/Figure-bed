# 进程、线程与作业

## 多道程序设计

> - 多道程序设计是OS所采用的最基本、最重要的技术，其根本目标是**提高系统的效率**。衡量系统效率的一个尺度是吞吐量。
> - 吞吐量: 单位时间内系统所处理的作业的道数。**$吞吐量={作业道数}/{全部处理时间}$**

### **单道程序设计的缺点**

#### **设备资源利用率低**

> 单道程序系统中，内存中仅存在一个程序，该程序仅能用到设备集中的一个子集，未被用到的外设资源便被浪费。

#### **内存资源利用率低**

> 随着硬件技术的提高，内存容量不断增加，目前已达上百兆或几个G，而一般程序的长度远小于内存容量。若采用单道程序设计，则内存空间的浪费很大。

#### **处理机资源利用率低** 

> 中断，通道，DMA控制器的引入，使处理器与I/O设备的可以并行。 

### **多道程序设计的提出**

#### 设备资源利用率提高

> 各种设备资源都会被用到并经常处于忙碌状态，设备利用率将得到明显提高。

#### 内存资源利用率提高

> 允许多道程序同时进入系统可避免单道程序过短而内存空间很大所造成的存储空间浪费。

#### 处理机资源利用率提高

> 在单道程序系统中，处理机资源利用率低的主要原因是当运行程序等待I/O操作完成时，处理机被闲置。若将两道程序同时放入内存，在一个程序等待I/O操作期间，处理机执行另一个程序，便可提高处理机的利用率。

> 增加同时运行程序的道数可提高系统资源利用率，从而提高系统效率，但道数应与系统资源数量相当。<u>道数过少，系统资源利用率低；道数过多，系统开销增大，程序响应速度下降。</u>

### 多道程序设计的问题

> 多道程序设计改善了系统资源的利用率，增加了吞吐量，提高了系统效率，但同时也带来了新的问题：即**资源竞争**。

#### 处理机资源管理问题

> 如果**可运行程序的个数多于处理机的个数**，则需解决可运行程序与处理机资源的竞争问题，即需要对处理机资源加以管理，实现处理机资源在各个程序之间的分配和调度。

#### 内存资源管理问题

> 1. 内存划分问题
> 2. 逻辑地址映射到内存物理地址，即**重定位  **
> 3. 存储空间的保护

#### 设备资源管理问题[^2]

> 尽管操作系统在选择程序进入系统时可以使进入系统的程序搭配相对合理，但由于<u>程序**使用资源**的不确定性以及程序**推进速度**的不确定性</u>，内存中的多道程序在使用设备时经常发生冲突，即多个程序同时要求使用同一资源，这就要求操作系统确定适当的分配策略，并据此对资源加以管理。

## 进程的引入

> - 多道程序设计中程序的活动规律：
>     推进→暂停→推进→暂停→…
> - 程序暂停时需将现场信息作为断点保存起来。
> - 程序推进时需恢复上次暂停时的现场信息,并从断点处继续执行。

### 进程的概念[^1]

> 1. 进程是<u>具有一定独立功能的程序</u>关于<u>一个数据集合</u>的<u>一次运行活动</u>，可并发执行的程序在<u>一个数据集合</u>上的运行过程。
>     2. 进程是程序的一次执行;
> 3. 进程是可参与并发执行的程序;
> 4. 进程是一个程序与数据一道通过处理机的执行所发生的活动;
> 5. 所谓进程, 就是一个程序在<u>给定的空间和初始环境</u>下, 在一个处理机上的执行过程。 

> 并发(concurrent) : 宏观同时，微观“交替执行”，不要求多个CPU。
>
> 并行(parallel) : 微观同时，要求多个CPU。 

### 进程状态及状态转换

#### 进程状态

##### 运行态(RUN)

> **进程占有CPU**，正在向前推进。单处理机系统中任一时刻只能有一个进程处于运行态。

##### 就绪态(READY)

> 进程本身**具备运行条件**, 但未得到CPU。
>
> **进程被创建时处于就绪态，进程创建成功，此时把该进程插入到就绪队列中 。**

##### 等待态(WAIT)(阻塞态)

> - 也称**挂起态**(Suspended)、**阻塞态**、**封锁态**(Blocked)、**睡眠态**(Sleep)。
> - 进程正等待某一个事件的发生，即使给它分配处理机也不能运行。

> 运行、就绪、等待是进程的**三种最基本的状态**。对于一个具体系统来说, 为了实现某种设计目标，进程状态的数量可能多于三个。

#### 	进程状态转换

> - 就绪=>运行：获得处理机
> - 运行=>就绪：剥夺处理机
> - 运行=>等待：申请资源未得到，启动I/O传输未完成
> - 等待=>就绪：得到所申请资源，I/O传输完成
>
> ![三态图](https://raw.githubusercontent.com/FANSENG/Figure-bed/master/Picture/操作系统/三态图.png)
>
> ![五态图](https://raw.githubusercontent.com/FANSENG/Figure-bed/master/Picture/操作系统/五态图.png)
>
> - 进程状态转换由操作系统完成，对用户透明。
> - 对于不同的处理机调度算法，上述进程转换图可能略有不同。例如**对于非剥夺调度，不存在由运行到就绪的状态转换。**

### 进程控制块（PCB）

> 多道系统中运行的程序需有一个**断点现场保存区域**，该区域设在**进程控制块**中。<u>进程控制块是进程存在的标志</u>，它由一组信息构成，这些信息是系统对进程进行管理所需要的。

#### 进程控制块的定义

> - 进程控制块是<u>标志进程存在的数据结构</u>，其中包含**系统对进程进行管理所需要的全部信息**。
>- **是进程实体的一部分，是<u>描述和控制、管理进程的记录型数据结构</u>，是进程存在的唯一标志。**

- 一版操作系统PCB所包含项目

![https://raw.githubusercontent.com/FANSENG/Figure-bed/master/Picture/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/PCB.png](https://raw.githubusercontent.com/FANSENG/Figure-bed/master/Picture/操作系统/PCB.png)

### 进程的组成与上下文

- 进程的俩种组成

    > 进程由两部分组成：**进程控制块PCB**和**程序**，其中**程序包括代码和数据**等
    >
    > **进程由三部分构成，ＰＣＢ，操作集（代码），数据集（数据）**。

#### 进程控制块PCB

> - PCB是**进程的“灵魂”**。由于PCB中包含程序的地址信息，通过它可找到程序在内存或外存的存放地址。
> - PCB存于系统空间，只有操作系统能够对其存取，用户程序不能访问。

#### 程序

> - **程序**是进程的“躯体”，其中包括**代码**和**数据**两部分。
> - **代码**在运行期间不修改自身，以支持程序共享。另外，在多道系统中，内存中同时存在多个程序，这些程序在内存中的存放位置**随机确定**，且在运行过程中可能会发生变化，因而代码必须能够浮动，即**不采用绝对地址**。
> - **数据**一般包括静态变量、动态堆和动态栈。 **堆**用来保存动态变量，**栈**用来保存用户子程序相互调用时的参数、局部变量、返回值、断点等。
> - 数据一般归进程私用，当然也有系统提供进程间数据共享功能，以实现进程间的信息交换。

- 进程俩种图示方法
    ![https://raw.githubusercontent.com/FANSENG/Figure-bed/master/Picture/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%BF%A9%E7%A7%8D%E8%A1%A8%E8%AE%B0%E6%96%B9%E6%B3%95.png](https://raw.githubusercontent.com/FANSENG/Figure-bed/master/Picture/操作系统/进程俩种表记方法.png)

- 进程运行时OS需为其设置相应的运行环境，如<u>系统堆栈、地址映射寄存器、打开文件表、PSW与PC、通用寄存器等</u>。
- **进程上下文**：在UNIX System Ⅴ中，将进程的**物理实体(PCB+程序)**与支持进程运行的**物理环境**称为进程上下文。
- **进程切换过程就是进程上下文切换的过程。**进程切换所需时间是系统为实现并发而付出的额外代价，属于系统开销的一部分。
- **系统开销**：系统开销一般指运行操作系统程序，对系统进行管理而花费的时间和空间。







---

[^1]:动态特性

[^2]:不确定性和冲突