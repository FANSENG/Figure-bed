# 8-1

## 共享后缀链表

### Polya四步法

1.**Understand the problem**

> ​		根据题目的描述，我们需要完善的函数Suffix有俩个输入值，链表`L1`和`L2`，`L1`和`L2`有共享后缀(如下图)，我们需要返回一个指向共享后缀的起始节点，也就是说我们想办法找到指向图中的节点`i`的指针然后返回这个指针就可以了。
>
> - 题目已知条件
>
>     > 1.L1和L2为带头结点的单链表
>     >
>     > 2.L1和L2有共享后缀
>
> ![https://raw.githubusercontent.com/FANSENG/Figure-bed/master/Picture/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE/%E5%85%B1%E4%BA%AB%E5%90%8E%E7%BC%80%E7%9A%84%E9%93%BE%E8%A1%A8.jpg](https://raw.githubusercontent.com/FANSENG/Figure-bed/master/Picture/数据结构课设/共享后缀的链表.jpg)
>
> ​		看上去很容易，一遍过问题不大！前提是，没看错题。
>
> 以下为错误示范：
>
> > 我拿到这个题的时候，大概扫了一眼，没有认真看题，所以就！！**理解错了题意**！！，我的眼睛和大脑认为本题给了我俩个有相同数据串的链表，要求我把这俩个链表合并成上图
> >
> > ，所以我开始了一堆无用的操作，先逆置俩个链表，从俩个逆置链表尾部开始向前遍历，找到第一个Data不同的节点，然后这个节点就是图中的word1中的节点`d`和word2中的节点`e`,看上去没有任何问题！好，然后一提交我就傻眼了，只有俩个是答案正确（瞎fxh碰上了特殊情况），然后又是对代码更更改改，依然过不了，提交了六七次，最多拿了2分，之后又看了眼题，才发现理解错了题意。

2.**Devise a plan**

> ​		当看清了题理解了题意之后，这个问题已经比较容易解答了，我们需要创建俩个指针分别遍历俩个链表，当俩个指针第一次指向同一个节点时，我们就找到了我们需要的，那怎么尽快的找到这个节点呢？可以把这个问题看做下图中的问题，俩个汽车分别从A，B以相同速度赶往C，怎么能保证A和B能在路口相遇？已知相同速度，B的路程要比A的路程长，那B就需要比A先走`B到路口距离`-`A到路口距离`，也就是当B走到D点时，A开始走。简单来说就是，先让B走到离路口距离和A一样远，然后A开始走。
>
> ![https://raw.githubusercontent.com/FANSENG/Figure-bed/master/Picture/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE/%E7%BA%B8%E7%89%8C%E6%B8%B8%E6%88%8F%E4%BB%A3%E6%9B%BF%E5%9B%BE.png](https://raw.githubusercontent.com/FANSENG/Figure-bed/master/Picture/数据结构课设/纸牌游戏代替图.png)
>
> ​		转化到本题中，就是让指向L1的指针(设为P1)指向节点`a`，然后L1和L2(设为P2)的指针同时向后移动，判断P1是否和P2相等，若相等返回P1，否则继续向后移动。

3.**Carry out the plan**

> - 首先先写出代码思想
>
> ```
> 得到L1长度len1和L2长度len2
> 根据len1和len2的大小来对齐指针p1和p2
> p1和p2同时向后遍历并判断p1和p2是否相等，若相等则返回
> ```
>
> - 下面是实际代码
>
> ```c
> PtrToNode Suffix(List L1, List L2) {
>     int len1 = 0, len2 = 0;
>     List p = L1->Next, p1 = L1->Next, p2 = L2->Next;
>     // 得到L1长度
>     while (p) {
>         len1++;
>         p = p->Next;
>     }
>     // 得到L2长度
>     p = L2->Next;
>     while (p) {
>         len2++;
>         p = p->Next;
>     }
>     // 对齐p1和p2
>     while (len1 > len2) {
>         len1--;
>         p1 = p1->Next;
>     }
>     while (len2 > len1) {
>         len2--;
>         p2 = p2->Next;
>     }
>     // p1和p2同时后移并判断
>     while (p1) {
>         if (p1 == p2) return p1;
>         p1 = p1->Next;
>         p2 = p2->Next;
>     }
>     return NULL;
> }
> ```

4.**Look back**

> - 除了上述方法还有一种蠢方法:
>
>     > 用一个俩层循环，p1每向后移动一次就用p2遍历L2，判断是否存在p1==p2，若找到直接返回即可。因为题目中说明了这是用来存储英文单词的，考虑到英文单词的长度，不可能超时，所以此方法可行。最坏情况下复杂度为`O(len1*len2)`
>
> - 上述代码的方法最坏情况复杂度为`O(len1+len2+abs(len1-len2)+min(len1,len2))`
>
> 我能想到的方法里，这个方法效率是最高的。

## 纸牌游戏

### 题目

	假设在一个布袋中放有 n 张纸牌，每张纸牌值为ki（1 ≤ i ≤ n），给定一整数 m，其中 1 ≤ n ≤ 50，1 ≤ m, ki ≤ 10^8。游戏规则是依次抽取四张纸牌，每次抽取后放回布袋。问是否存在所抽取的四张纸牌面值之和等于 m。如果有则返回 YES，否则返回No。