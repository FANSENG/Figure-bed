# **8-1** **查找（二分、哈希）作业**

## 6-1 二分查找 (20分)

本题要求实现二分查找算法。

### 函数接口定义：

```c
Position BinarySearch( List L, ElementType X );
```

其中`List`结构定义如下：

```c
typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
}; 
```

`L`是用户传入的一个线性表，其中`ElementType`元素可以通过>、==、<进行比较，并且题目保证传入的数据是递增有序的。函数`BinarySearch`要查找`X`在`Data`中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记`NotFound`。

### 裁判测试程序样例：

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 10
#define NotFound 0
typedef int ElementType;

typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};

List ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */
Position BinarySearch( List L, ElementType X );

int main()
{
    List L;
    ElementType X;
    Position P;

    L = ReadInput();
    scanf("%d", &X);
    P = BinarySearch( L, X );
    printf("%d\n", P);

    return 0;
}
/* 你的代码将被嵌在这里 */
```

### 输入样例1：

```
5
12 31 55 89 101
31 
```

### 输出样例1：

```
2
```

### 输入样例2：

```
3
26 78 233
31
```

### 输出样例2：

```
0
```

### 应用Polya四步法解决问题

1. 理解问题(Understand the problem)

    > ​		题目要我们完成函数`BinarySearch( List L, ElementType X )`，其中输入参数`List L`包含一个递增排序的线性表和线性表中最后一个元素的位置，线性表中第一个元素下标为1，`ElementType X`为我们要查找的元素值，最后返回值为查找到元素的下标，若没有找到则返回`NotFound`。要求使用的方法为二分查找。

2. 设计方案(Devise a plan)

    > ​		题目已经告知我们具体需要使用的方法了，用二分查找实现就可以了，设置三个位置参数`left,right,mid`，在循环中去查找，每轮去更新三个位置参数的值就可以了。二分查找已经学过多次了，思想此处就不赘述了。下面说一下写代码时需要注意的几点:
    >
    > > 1. 当跳出循环后(即left>=right)需要判断`L->Data[mid]`是否等于`X`
    > > 2. 计算`mid`时应注意计算方法，若使用`(right+left)/2`有溢出的可能，应改为`left+(right-left)/2`

3. 实施计划(Carry out the plan)

    > 实现代码如下
    >
    > ```c
    > Position BinarySearch( List L, ElementType X ){
    >     Position left = 1, right = L->Last, mid=right/2;
    >     while(left<right){
    >         if(L->Data[mid]==X)
    >             return mid;
    >         else if(L->Data[mid]<X)
    >             left = mid + 1;
    >         else
    >             right = mid - 1;
    >         mid = left+(right-left)/2;
    >     }
    >     if(L->Data[mid]==X)
    >         return mid;
    >     else
    >         return NotFound;
    > }
    > ```

4. 反思回顾(Look back)

    > ​		对于二分查找，我们应该清楚它的使用条件。首先进行查找的数据必须是有序的，这个很好解释，如果查找数据无序，我们就不能确定下一次进行二分查找的范围；其次，对查找数据中任意一个元素访问的时间复杂度应为$O(1)$，如果访问的时间复杂度不是$O(1)$的话，如链表，二分查找的代价就会很大，大部分情况下甚至没有暴力搜索块。
    >
    > ​		在代码编写时应当注意数据的范围（防止溢出），以及循环的边界条件。

## 7-1 特立独行的幸福 (25分)

对一个十进制数的各位数字做一次平方和，称作一次迭代。如果一个十进制数能通过若干次迭代得到 1，就称该数为幸福数。1 是一个幸福数。此外，例如 19 经过 1 次迭代得到 82，2 次迭代后得到 68，3 次迭代后得到 100，最后得到 1。则 19 就是幸福数。显然，在一个幸福数迭代到 1 的过程中经过的数字都是幸福数，它们的幸福是依附于初始数字的。例如 82、68、100 的幸福是依附于 19 的。而一个**特立独行**的幸福数，是在一个有限的区间内不依附于任何其它数字的；其**独立性**就是依附于它的的幸福数的个数。如果这个数还是个素数，则其独立性加倍。例如 19 在区间[1, 100] 内就是一个特立独行的幸福数，其独立性为 2×4=8。

另一方面，如果一个大于1的数字经过数次迭代后进入了死循环，那这个数就不幸福。例如 29 迭代得到 85、89、145、42、20、4、16、37、58、89、…… 可见 89 到 58 形成了死循环，所以 29 就不幸福。

本题就要求你编写程序，列出给定区间内的所有特立独行的幸福数和它的独立性。

### 输入格式：

输入在第一行给出闭区间的两个端点：1<*A*<*B*≤104。

### 输出格式：

按递增顺序列出给定闭区间 [*A*,*B*] 内的所有特立独行的幸福数和它的独立性。每对数字占一行，数字间以 1 个空格分隔。

如果区间内没有幸福数，则在一行中输出 `SAD`。

### 输入样例 1：

```in
10 40
```

### 输出样例 1：

```out
19 8
23 6
28 3
31 4
32 3
```

**注意：**样例中，10、13 也都是幸福数，但它们分别依附于其他数字（如 23、31 等等），所以不输出。其它数字虽然其实也依附于其它幸福数，但因为那些数字不在给定区间 [10, 40] 内，所以它们在给定区间内是特立独行的幸福数。

### 输入样例 2：

```in
110 120
```

### 输出样例 2：

```out
SAD
```

### 应用Polya四步法解决问题

1. 理解问题(Understand the problem)

    > 

2. 设计方案(Devise a plan)

    > 

3. 实施计划(Carry out the plan)

    > 

4. 反思回顾(Look back)

    > 